<link href="../polymer/polymer.html" rel="import">
<link href="../paper-ripple/paper-ripple.html" rel="import">
<link href="../iron-resizable-behavior/iron-resizable-behavior.html" rel="import">
<link href="paper-color-picker-behavior.html" rel="import">

<dom-module id="paper-color-circle">
  <template>
    <style>
      :host {
        display: inline-block;
        position: relative;
      }

      canvas {
        min-width: 100px;
        min-height: 100px;
        cursor: crosshair;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      #ripple-container {
        position: relative;
        margin: auto;
      }
    </style>

    <div id="ripple-container">
      <canvas
        id="canvas"
        on-down="_onDown"
        on-up="_onUp"
        on-track="_onMove">
      </canvas>
      <paper-ripple
        id="ripple"
        class$="{{ shape }}"
        recenters
        noink>
      </paper-ripple>
    </div>
  </template>

  <script>
    Polymer({

      is: 'paper-color-circle',

      properties: {
        /**
          * A AA border can be drawn to prevent jagged edges on circles
          *
          * @attribute colouredAaBorder
          * @type boolean
          * @default false
          */
        noAaBorder: {
          type: Boolean,
          value: false
        },

        _ctx: {
          type: Object,
          value: function () {
            return {};
          }
        },

        /**
          * A coloured AA border can be drawn to prevent jagged edges on circles
          *
          * @attribute colouredAaBorder
          * @type Array
          * @default false
          */
        colouredAaBorder: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
          * square, circle or huebox
          *
          * @attribute shape
          * @type string
          * @default 'circle'
          */
        shape: {
          type: String,
          value: 'circle',
          notify: true
        },

        /**
          * hsv OR hsl
          *
          * @attribute type
          * @type string
          * @default 'hsv'
          */
        type: {
          type: String,
          value: 'hsv',
          notify: true
        },

        size: {
          type: Number
        }
      },

      observers: [
        '_brightnessChanged(brightness)',
        '_luminosityChanged(luminosity)',
        '_colorChanged(red, green, blue)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior,
        PaperColorPicker.ColorBehavior
      ],

      listeners: {
        'iron-resize': 'redraw'
      },

      _pickColor: function (e) {
        var rect = this.getBoundingClientRect();
        var touchX = e.detail.x - rect.left;
        var touchY = e.detail.y - rect.top;
        var color = this._ctx.getImageData(touchX, touchY, 1, 1).data;

        if (this.shape === 'circle') {
          var distance = Math.abs(
            Math.sqrt(
              Math.pow(touchX - this.size / 2, 2) +
              Math.pow(touchY - this.size / 2, 2)
            ) - this.size / 2
          );

          if (distance < this.size / 100) return;
        }

        if (color[3] > 0 && color[3] == 255) {
          this.set('red', color[0]);
          this.set('green', color[1]);
          this.set('blue', color[2]);
          if (!this.noAaBorder && this.colouredAaBorder)
            this.redraw();
        }
      },

      _onDown: function (e) {
        this._pickColor(e);
        this.set('_trackingColorChanges', true);
      },

      _onMove: function (e) {
        this._pickColor(e);
      },

      _onUp: function (e) {
        this.set('_trackingColorChanges', false);
        this.$.ripple.style.color = 'rgb(' +
          this.red + ', ' +
          this.green + ', ' +
          this.blue + ')';

        this.$.ripple.downAction(e);
        this.async(function () {
          this.$.ripple.upAction();
        })
      },

      redraw: function () {
        this.debounce('redraw', function () {
          var size = this.getBoundingClientRect();
          var width = size.width;
          var height = size.height;

          if (width == 0 || height == 0) {
            var computedStyle = window.getComputedStyle(this);
            width = parseInt(computedStyle.width);
            height = parseInt(computedStyle.height);
          }

          this.set('size', Math.floor(Math.min(width, height)));
          this.$.canvas.width = this.size;
          this.$.canvas.height = this.size;
          this.$['ripple-container'].style.width = this.size + 'px';
          this.$['ripple-container'].style.height = this.size + 'px';

          var halfsize = this.size / 2;
          var bitmap = this._ctx.getImageData(0, 0, this.size, this.size);

          for (var y = 0; y < this.size; y++) {
            for (var x = 0; x < this.size; x++) {
              // offset for the 4 RGBA values in the data array
              var offset = 4 * ((y * this.size) + x);
              var color = [255, 255, 255];

              if (this.shape === 'circle') {
                var distanceFromCenter = Math.sqrt(
                  Math.pow(y - halfsize, 2) + Math.pow(x - halfsize, 2)
                ) / halfsize;
                if (distanceFromCenter < halfsize / halfsize - 0.01) {
                  var hue = Math.atan2(y - halfsize, x - halfsize) * (180 / Math.PI);
                  if (hue < 0) hue+=360;
                  var saturation = Math.round(distanceFromCenter * 1000) / 1000;
                  saturation = Math.min(1, saturation);
                  if (this.type === 'hsv') {
                    var value = Math.round(this.brightness * 1000) / 1000;
                    color = this.hsv2rgb(hue, saturation, value);
                  } else if (this.type === 'hsl') {
                    var lightness = Math.round(this.lightness * 1000) / 1000;
                    color = this.hsl2rgb(hue, saturation, lightness);
                  }
                };
              } else if (this.shape === 'huebox') {
                var saturation = x / width;
                var hue = Math.round(this.hue * 1000) / 1000 * 360;
                var third = 1 - y / this.size;
                if (this.type === 'hsv') {
                  color = this.hsv2rgb(hue, saturation, third);
                } else if (this.type === 'hsl') {
                  color = this.hsl2rgb(hue, saturation, third);
                }
              } else if (this.shape === 'square') {
                var hue = x / width * 360;
                var saturation = 1 - y / this.size;
                if (this.type === 'hsv') {
                  var value = Math.round(this.brightness * 1000) / 1000;
                  color = this.hsv2rgb(hue, saturation, value);
                } else if (this.type === 'hsl') {
                  var lightness = Math.round(this.lightness * 1000) / 1000;
                  color = this.hsl2rgb(hue, saturation, lightness);
                }
              }

              bitmap.data[offset + 0] = color[0];
              bitmap.data[offset + 1] = color[1];
              bitmap.data[offset + 2] = color[2];
              bitmap.data[offset + 3] = 255; // no transparency
            };
          };
          this._ctx.putImageData(bitmap, 0, 0);
          if (!this.noAaBorder && this.shape === 'circle') {
            // Getting a nice anti-aliased edge using canvas is hard,
            // so instead a white circle is drawn over the border
            this.drawAACircle();
          }
        }, 1);
      },

      drawAACircle: function () {
        if (this.colouredAaBorder) {
          if (this.green) {
            this.set('_ctx.strokeStyle',
                     'rgb(' + this.red + ',' + this.green + ',' + this.blue + ')');
          } else {
            this.set('_ctx.strokeStyle', 'rgb(' +
                     this.colouredAaBorder[0] + ',' +
                     this.colouredAaBorder[1] + ',' +
                     this.colouredAaBorder[2] + ')');
          }
        } else {
          this.set('_ctx.strokeStyle', 'rgba(255, 255, 255, 0.99)');
        }
        this.set('_ctx.lineWidth', this.size / 100);
        this._ctx.beginPath();
        var borderRadius = this.size / 2;
        this._ctx.arc(this.size / 2, this.size / 2, borderRadius - 1, 0, 2 * Math.PI, false);
        this._ctx.closePath();
        this._ctx.stroke();
      },

      _brightnessChanged: function (brightness) {
        this.redraw();
      },

      _luminosityChanged: function (luminosity) {
        this.redraw();
      },

      _colorChanged: function (red, green, blue) {
        if (!this._trackingColorChanges) {
          if (this.type == 'hsl') {
            var hsl = this.rgb2hsl(red, green, blue);
            this.hue = hsl[0];
            this.lightness = hsl[2];
          } else if (this.type == 'hsv') {
            var hsv = this.rgb2hsv(red, green, blue);
            if (!isNaN(hsv[0])) this.hue = hsv[0];
            this.brightness = hsv[2];
          }
        }
      },

      ready: function () {
        this.set('_ctx', this.$.canvas.getContext('2d'));
        this.redraw();
      }
    });
  </script>
</dom-module>
